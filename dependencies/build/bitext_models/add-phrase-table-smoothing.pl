#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long "GetOptions";

my @args=@ARGV;
for(my $i=0; $i<@args; $i++) {
    if($args[$i]=~/[\= ]\-/ || $args[$i]=~/ /) {
	my($feature,$value)=$args[$i]=~/^([^ \=]+?)[\= ](.+)$/;
	$args[$i]="$feature\=\"$value\"";
    }
}
my $arg_string=join(' ',@args);
print STDERR "call: $0 $arg_string\n\n";


BEGIN {
    if(!defined($ENV{'OISTERHOME'})
       || $ENV{'OISTERHOME'} eq '') {
        print STDERR "environment variable OISTERHOME must be set:\n";
        print STDERR "export OISTERHOME=/path/to/oister/distribution\n";
        exit(-1);
    }
}

BEGIN {
    my $release_info=`cat /etc/*-release`;
    $release_info=~s/\n/ /g;
    my $os_release;
    if($release_info=~/CentOS release 5\./) {
        $os_release='CentOS_5';
    } elsif($release_info=~/CentOS release 6\./) {
        $os_release='CentOS_6';
    }
    if($os_release eq 'CentOS_6') {
        unshift @INC, $ENV{"OISTERHOME"}."/lib/perl_modules/lib64/perl5"
    } else {
        unshift @INC, $ENV{"OISTERHOME"}."/resources/bin/lib64/perl5/site_perl/5.8.8/x86_64-linux-thread-multi"
    }
}

use PerlIO::gzip;

my $OISTERHOME=$ENV{'OISTERHOME'};

my $pid=$$;

my $phrase_table;
my $phrase_table_smoothed;
my $use_kn_smoothing=0;
my $use_elf=0;
my $use_gt_smoothing=0;
my $base=10;
my $nonsmooth_maxfreq=10;
my $external_path;
my $config_pt_part_file;

my $max_lines;#=100000;


my $java='/usr/bin/java';

my $arff_file="gt\_$pid.arff";


my $_HELP;
$_HELP = 1
    unless &GetOptions(
      "phrase-table|pt=s" => \$phrase_table,
      "phrase-table-smooth|pt-smooth|pt-smoothed|phrase-table-smoothed=s" => \$phrase_table_smoothed,
      "gt" => \$use_gt_smoothing,
      "kn" => \$use_kn_smoothing,
      "external-path|ext-path=s" => \$external_path,
      "elf" => \$use_elf,
      "help" => \$_HELP
		       );

if(!defined($external_path)) {
    print STDERR "  --external-path=str must be set\n";
    $_HELP=1;
}

if(!defined($use_kn_smoothing) && !defined($use_gt_smoothing) && !defined($use_elf)) {
    print STDERR "You didn't choose any smoothing method.\n\n";
    $_HELP=1;
}

if($_HELP || !defined($phrase_table)) {
    print "\nOptions:
  --external-path=str : path to 3rd party software directory generated by
           $OISTERHOME/install/scripts/oister-link-external-components.pl
  --pt=str : phrase table
  --pt-smooth=str : name of new phrase-table
  --kn : use Kneser-Ney smoothing
  --gt : use Good-Turing smoothing
  --elf : add enhanced low-frequency feature
  --help : print this message.\n\n";
    exit(-1); 
}

my($phrase_table_stem)=$phrase_table=~/^(.+?)(?:\.gz)?$/;
my($phrase_table_smoothed_stem)=$phrase_table_smoothed=~/^(.+?)(?:\.gz)?$/;


my $weka_regression_call="$java -cp $external_path/external_binaries/weka.jar weka.classifiers.functions.LinearRegression -t $arff_file >& $arff_file.out";

my $n1=0;
my $n2=0;
my $n3=0;
my $n4=0;
my $total_number_phrase_pairs=0;
my $total_number_phrase_pair_occurrences=0;
my %num_unique_src_phrases;
my %num_unique_trg_phrases;
my %phrase_count_src;
my %phrase_count_trg;

if($phrase_table=~/\.gz$/o) {
    open F, "<:gzip", $phrase_table, or die("can't open $phrase_table: $!\n");
} else {
    open(F,"<$phrase_table") || die("can't open $phrase_table: $!\n");
}

my $no_lines_processed=0;
my $prev_no_lines=0;
my @count_of_counts;

 
while(defined(my $line=<F>)) {
    chomp($line);
    my($f,$e,$score_string,$a_string,$freq_string,$oister_features_string)=split(/ \|\|\| /,$line);

    my(@freqs)=split(/ /,$freq_string);
    my $freq=$freqs[-1];

   if($freq==1) {
	$n1++;
    } elsif($freq==2) {
	$n2++;
    } elsif($freq==3) {
	$n3++;
    } elsif($freq==4) {
	$n4++;
    }

    $no_lines_processed++;
    last if(defined($max_lines) && $no_lines_processed>$max_lines);

    my $no_digits = rindex($prev_no_lines,"");
    if($no_lines_processed % 100000 == 0) {
        for(my $j=1; $j<=$no_digits; $j++) {
            print STDERR "\x08";
        };
        print STDERR "$no_lines_processed";
        $prev_no_lines = $no_lines_processed;
    }


    $num_unique_src_phrases{$e}[0]++;
    $num_unique_trg_phrases{$f}[0]++;

    my $d_index=&min(3,$freq);
    $num_unique_src_phrases{$e}[$d_index]++;
    $num_unique_trg_phrases{$f}[$d_index]++;

    $count_of_counts[$freq]++;

#    $phrase_count_src{$f}+=$freq;
#    $phrase_count_trg{$e}+=$freq;

    $total_number_phrase_pairs++;
    $total_number_phrase_pair_occurrences+=$freq;

}
close(F);


my $Y=$n1/($n1+2*$n2);
my $D1=1-(2*$Y*($n2/$n1));
my $D2=2-(3*$Y*($n3/$n2));
my $D3=3-(4*$Y*($n4/$n3));

print STDERR "\n\nY=$Y\n";
print STDERR "D1=$D1\n";
print STDERR "D2=$D2\n";
print STDERR "D3=$D3\n\n";

my @cg;
my %cg_sum_f;
my %cg_sum_e;
my $gt_n_1;

if($use_gt_smoothing) {
    my $y_intercept;
    my $slope;
    my @count_of_counts_log;
    my @count_of_counts_r;
    my @count_of_counts_Nr;

    for(my $i=1; $i<@count_of_counts; $i++) {
	if(defined($count_of_counts[$i])) {
	    push(@count_of_counts_r,$i);
	    push(@count_of_counts_Nr,$count_of_counts[$i]);
	}
    }
    my @count_of_counts_Zr;
    &average_transform(\@count_of_counts_r,\@count_of_counts_Nr,\@count_of_counts_Zr);

    for(my $i=0; $i<@count_of_counts_r; $i++) {
	my $c_log=&log_base($count_of_counts_r[$i],$base);
	my $n_c_log=&log_base($count_of_counts_Zr[$i],$base);
	my $instance="$c_log\,$n_c_log,\{1\}";
	push(@count_of_counts_log,$instance);
    }
    &run_linear_regression(\@count_of_counts_log,\$y_intercept,\$slope);
    print STDERR "slope=$slope y-intercept=$y_intercept\n";

    my @count_of_counts_estimated;
    for(my $i=1; $i<@count_of_counts+1; $i++) {
#	my $n_c_estimated=&max(1,sprintf("%.0f",exp(log($i)*$slope+$y_intercept)));
	my $n_c_estimated=&exp_base(&log_base($i,$base)*$slope+$y_intercept,$base);
	$count_of_counts_estimated[$i]=$n_c_estimated;
	if($i==1) {
#	    $gt_n_1=$n_c_estimated;
	    $gt_n_1=$count_of_counts[1];
	}
    }

    for(my $c=1; $c<@count_of_counts; $c++) {

	next if(!defined($count_of_counts[$c]));

	my $c_g=($c+1)*$count_of_counts_estimated[$c+1]/$count_of_counts_estimated[$c];
	my $c_g_nonsmooth;
	if($c<=$nonsmooth_maxfreq && defined($count_of_counts[$c]) && defined($count_of_counts[$c+1])) {
	    my $var_smooth=(($c+1)**2)
		*($count_of_counts_estimated[$c+1]/$count_of_counts_estimated[$c]**2)
		*(1+$count_of_counts_estimated[$c+1]/$count_of_counts_estimated[$c]);
	    my $var_nonsmooth=(($c+1)**2)
		*($count_of_counts[$c+1]/$count_of_counts[$c]**2)
		*(1+$count_of_counts[$c+1]/$count_of_counts[$c]);
	    my $stddev_smooth=sqrt($var_smooth);
	    my $stddev_nonsmooth=sqrt($var_nonsmooth);

	    if($stddev_smooth>1.96*$stddev_nonsmooth || $stddev_nonsmooth>1.96*$stddev_smooth) {
		$c_g=($c+1)*$count_of_counts[$c+1]/$count_of_counts[$c];
		$c_g_nonsmooth=$c_g;
	    }
	}

	$cg[$c]=$c_g;

	if(0) {
	    print STDERR "count_of_counts[$c]=$count_of_counts_estimated[$c] cg=$c_g";
	    if(defined($count_of_counts[$c])) {
		print STDERR " orig: $count_of_counts[$c]";
		if(defined($c_g_nonsmooth)) {
		    print STDERR " c_g_nonsmooth=$c_g_nonsmooth";
		}
	    }
	    print STDERR "\n";
	}
    }

    if($phrase_table=~/\.gz$/o) {
	open F, "<:gzip", $phrase_table, or die("can't open $phrase_table: $!\n");
    } else {
	open(F,"<$phrase_table") || die("can't open $phrase_table: $!\n");
    }
    $no_lines_processed=0;
    $prev_no_lines=0;
    while(defined(my $line=<F>)) {
	chomp($line);

	my($f,$e,$score_string,$a_string,$freq_string,$oister_features_string)=split(/ \|\|\| /,$line);
	my($freq_trg,$freq_src,$freq)=split(/ /,$freq_string);

#	my @scores=split(/ +/,$score_string);
#	my $freq=$scores[$freq_index];
	
	$no_lines_processed++;
	last if(defined($max_lines) && $no_lines_processed>$max_lines);
	
	my $no_digits = rindex($prev_no_lines,"");
	if($no_lines_processed % 10000 == 0) {
	    for(my $j=1; $j<=$no_digits; $j++) {
		print STDERR "\x08";
	    };
	    print STDERR "$no_lines_processed";
	    $prev_no_lines = $no_lines_processed;
	}

	$cg_sum_f{$f}+=$cg[$freq];
	$cg_sum_e{$e}+=$cg[$freq];
    }
    close(F);
    print STDERR "\n";
}


if($phrase_table=~/\.gz$/o) {
    open F, "<:gzip", $phrase_table, or die("can't open $phrase_table: $!\n");
} else {
    open(F,"<$phrase_table") || die("can't open $phrase_table: $!\n");
}

if($phrase_table_smoothed=~/\.gz$/o) {
    open G, ">:gzip", $phrase_table_smoothed, or die("can't open $phrase_table_smoothed: $!\n");
} else {
    open(G,">$phrase_table_smoothed") || die("can't open $phrase_table_smoothed: $!\n");
}
 
$no_lines_processed=0;
$prev_no_lines=0;
while(defined(my $line=<F>)) {
    chomp($line);

    my($f,$e,$score_string,$a_string,$freq_string,$oister_features_string)=split(/ \|\|\| /,$line);
    my($freq_trg,$freq_src,$freq)=split(/ /,$freq_string);

    my $D;
    if($freq==1) {
	$D=$D1;
    } elsif($freq==2) {
	$D=$D2;
    } else {
	$D=$D3;
    }

    $no_lines_processed++;
    last if(defined($max_lines) && $no_lines_processed>$max_lines);

    my $no_digits = rindex($prev_no_lines,"");
    if($no_lines_processed % 10000 == 0) {
        for(my $j=1; $j<=$no_digits; $j++) {
            print STDERR "\x08";
        };
        print STDERR "$no_lines_processed";
        $prev_no_lines = $no_lines_processed;
    }

    for(my $i=1; $i<4; $i++) {
	if(!defined($num_unique_src_phrases{$e}[$i])) {
	    $num_unique_src_phrases{$e}[$i]=0;
	}
	if(!defined($num_unique_trg_phrases{$f}[$i])) {
	    $num_unique_trg_phrases{$f}[$i]=0;
	}
    }


    my(@new_scores);

    if($use_kn_smoothing) {
    # p_kn(f|e)
#    my $alpha_t=$D*($num_unique_src_phrases{$e}[0]/$phrase_count_trg{$e});
	my $alpha_t=$D*($num_unique_src_phrases{$e}[0]/$freq_trg);
	my $gamma_t=(($D1*$num_unique_src_phrases{$e}[1]
		      +$D2*$num_unique_src_phrases{$e}[2]
		      +$D3*$num_unique_src_phrases{$e}[3])/$freq_trg);
	
	my $p_b_s=$num_unique_trg_phrases{$f}[0]/$total_number_phrase_pairs;
	my $kn_e2f=(($freq-$D)/$freq_trg)+($gamma_t*$p_b_s);
	
	# p_kn(e|f)
#    my $alpha_s=$D*($num_unique_trg_phrases{$f}[0]/$phrase_count_src{$f});
	my $alpha_s=$D*($num_unique_trg_phrases{$f}[0]/$freq_src);
	my $gamma_s=(($D1*$num_unique_trg_phrases{$f}[1]
		      +$D2*$num_unique_trg_phrases{$f}[2]
#		  +$D3*$num_unique_trg_phrases{$f}[3])/$phrase_count_src{$f});
		      +$D3*$num_unique_trg_phrases{$f}[3])/$freq_src);
	
	my $p_b_t=$num_unique_src_phrases{$e}[0]/$total_number_phrase_pairs;
	my $kn_f2e=(($freq-$D)/$freq_src)+($gamma_s*$p_b_t);
	

	$kn_e2f=sprintf("%.6f",$kn_e2f);
	$kn_e2f=~s/0+$//;
	$kn_e2f=~s/\.$//;
	$kn_e2f=10**-10 if($kn_e2f==0);
	
	$kn_f2e=sprintf("%.6f",$kn_f2e);
	$kn_f2e=~s/0+$//;
	$kn_f2e=~s/\.$//;
	$kn_f2e=10**-10 if($kn_f2e==0);

	push(@new_scores,$kn_e2f);
	push(@new_scores,$kn_f2e);
    }	

    if($use_gt_smoothing) {

	my $gt_e2f;    
	my $gt_f2e;    

#	my $prob_e=$phrase_count_trg{$e}/$total_number_phrase_pair_occurrences;
#	my $prob_f=$phrase_count_src{$f}/$total_number_phrase_pair_occurrences;
	my $prob_e=$freq_trg/$total_number_phrase_pair_occurrences;
	my $prob_f=$freq_src/$total_number_phrase_pair_occurrences;
	$gt_e2f=$cg[$freq]/($cg_sum_e{$e}+$prob_e*$gt_n_1);
	$gt_f2e=$cg[$freq]/($cg_sum_f{$f}+$prob_f*$gt_n_1);

	$gt_e2f=sprintf("%.6f",$gt_e2f);
	$gt_e2f=~s/0+$//;
	$gt_e2f=~s/\.$//;
	$gt_e2f=10**-10 if($gt_e2f==0);

	$gt_f2e=sprintf("%.6f",$gt_f2e);
	$gt_f2e=~s/0+$//;
	$gt_f2e=~s/\.$//;
	$gt_f2e=10**-10 if($gt_f2e==0);	

	push(@new_scores,$gt_e2f);
	push(@new_scores,$gt_f2e);
    }

    if($use_elf) {
	my $elf_score=exp(-1/$freq);
	$elf_score=sprintf("%.6f",$elf_score);
	$elf_score=~s/0+$//;
	$elf_score=~s/\.$//;
	$elf_score=10**-10 if($elf_score==0);

	push(@new_scores,$elf_score);
    }

    
    my $feature_string=join(' ',@new_scores);
    my $feature_name='pt';
    $oister_features_string=&add_entries_to_oister_features($oister_features_string,$feature_name,$feature_string);
    print G "$f ||| $e ||| $score_string ||| $a_string ||| $freq_string ||| $oister_features_string\n";

}
close(F);
close(G);
print STDERR "\n";

if(-e "$phrase_table_stem.config\_info") {
    my @config_buffer_pt;
    my @config_buffer_other;

    my $last_index=&read_pt_config_info("$phrase_table_stem.config\_info",\@config_buffer_pt,\@config_buffer_other);
    if($use_kn_smoothing) {
	$last_index++;
	push(@config_buffer_pt,"feature:phrase_table[$last_index].kn(f|e)=0.01(-10)\tinit=0.1[0.1,0.3]\topt=0.1[0.1,0.3]");
	$last_index++;
	push(@config_buffer_pt,"feature:phrase_table[$last_index].kn(e|f)=0.01(-10)\tinit=0.1[0.1,0.3]\topt=0.1[0.1,0.3]");
    }

    if($use_gt_smoothing) {
	$last_index++;
	push(@config_buffer_pt,"feature:phrase_table[$last_index].gt(f|e)=0.01(-10)\tinit=0.1[0.1,0.3]\topt=0.1[0.1,0.3]");
	$last_index++;
	push(@config_buffer_pt,"feature:phrase_table[$last_index].gt(e|f)=0.01(-10)\tinit=0.1[0.1,0.3]\topt=0.1[0.1,0.3]");
    }

    if($use_elf) {
	$last_index++;
	push(@config_buffer_pt,"feature:phrase_table[$last_index].elf=0.01(-10)\tinit=0.1[0.1,0.3]\topt=0.1[0.1,0.3]");
    }

    open(F,">$phrase_table_smoothed_stem.config\_info");
    print F join("\n",@config_buffer_pt), "\n";
    print F "\n";
    print F join("\n",@config_buffer_other), "\n";
    close(F);
}


sub min {
    return $_[0] if($_[0]<$_[1]);
    return $_[1];
}

sub max {
    return $_[0] if($_[0]>$_[1]);
    return $_[1];
}


sub run_linear_regression {
    my($instances,$y_intercept,$slope)=@_;

    open(F,">$arff_file");
    print F "\@RELATION GT\n\n";
    print F "\@ATTRIBUTE C NUMERIC\n";
    print F "\@ATTRIBUTE NC NUMERIC\n";
    print F "\n\@DATA\n";
    
    for(my $i=0; $i<@$instances; $i++) {
	print F $instances->[$i], "\n";
    }
    close(F);

    print STDERR "$weka_regression_call";
    system($weka_regression_call);

    open(F,"<$arff_file.out");
    while(defined(my $line=<F>)) {
	if($line=~/^[\s\t]*([\-\.e0-9]+)\s\*\sC\s\+/) {
	    $$slope=$1;
	    $line=<F>;
	    ($$y_intercept)=$line=~/^[\s\t]*([\-\.e0-9]+)[\s\t]*\n/;
	    last;
	}
    }
    close(F);
    unlink($arff_file);
    unlink("$arff_file.out");
}

sub average_transform {
    my($count_of_counts_r,$count_of_counts_Nr,$count_of_counts_Zr)=@_;

    $count_of_counts_Zr->[0]=$count_of_counts_Nr->[0];
    $count_of_counts_Zr->[-1]=$count_of_counts_Nr->[-1];

    for(my $i=1; $i<@$count_of_counts_r-1; $i++) {
	$count_of_counts_Zr->[$i]=(2*$count_of_counts_Nr->[$i])/($count_of_counts_r->[$i+1]-$count_of_counts_r->[$i-1]);
    }
    my $last_index=@$count_of_counts_Nr-1;
    my $last_diff=$count_of_counts_r->[-1]-$count_of_counts_r->[-2];
    $count_of_counts_Zr->[$last_index]=(2*$count_of_counts_Nr->[$last_index])/(2*$last_diff);
}

sub log_base {
    my($x,$b)=@_;
    if(!defined($b)) {
	return log($x);
    } else {
	return log($x)/log($b);
    }
}


sub exp_base {
    my($x,$b)=@_;
    if(!defined($b)) {
	return exp($x);
    } else {
	return $b**$x;
    }
}

sub add_entries_to_oister_features {
    my($current_features_string,@feature_name_value_pairs)=@_;
    $current_features_string||='';

    my %feature_entries;
    my(@parts)=split(/ \|\| /,$current_features_string);
    for(my $i=0; $i<@parts; $i++) {
	my($feature_name,$feature_value)=$parts[$i]=~/^([^ ]+)\s*\=\s*(.*)$/;
	$feature_value||='';
	$feature_entries{$feature_name}=$feature_value;
    }
    # oister default feature:
    $feature_entries{'_oister'}='';
    
    for(my $i=0; $i<@feature_name_value_pairs-1; $i+=2) {
	my $feature_name=$feature_name_value_pairs[$i];
	my $feature_value=$feature_name_value_pairs[$i+1];
	if(exists($feature_entries{$feature_name}) 
	   && defined($feature_entries{$feature_name})
	   && $feature_entries{$feature_name} ne '') {
	    $feature_entries{$feature_name}.= " $feature_value";
	} else {
	    $feature_entries{$feature_name}=$feature_value;
	}
    }

    my @sorted_parts; #=qw( _oister= );
    foreach my $feature_name (sort (keys %feature_entries)) {
	push(@sorted_parts,"$feature_name\=$feature_entries{$feature_name}");
    }
    return join(' || ',@sorted_parts);
}


sub read_pt_config_info {
    my($file,$buffer_pt,$buffer_other)=@_;

    my $last_index=-1;
    open(F,"<$file")||die("can't open file $file: $!\n");
    while(defined(my $line=<F>)) {
        chomp($line);
        if($line=~/^\s*feature\:phrase\_table\[([0-9]+)\]/) {
            my $index=$1;
            if($index>$last_index) {
                $last_index=$index;
            }
            push(@$buffer_pt,$line);
        } elsif($line!~/^[\s\t]*$/) {
            push(@$buffer_other,$line);
        }
    }
    close(F);
    return $last_index;
}
