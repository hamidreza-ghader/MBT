#!/usr/bin/perl -w

use strict;
use warnings;
use Getopt::Long "GetOptions";
use File::Spec::Functions;
use FindBin '$Bin';
use PerlIO::gzip;

my $_HELP;
my $text_file;
my $lm_file;
my $batch_size=1000000;
my $srilm_path;
my $min_counts_string='1-1-1-2-2';
my $order=5;
my $smoothing='kndiscount';
my $no_interpolation=0;
my $keep_files=0;
my $working_dir='working_dir';
my $preprocessing_flags='lc,numsub,dedupl,sent_tags';

$_HELP = 1
    unless &GetOptions(
  "text|t=s" => \$text_file,
  "batch-size|b=i" => \$batch_size,
  "srilm-path=s" => \$srilm_path,
  "lm=s" => \$lm_file,
  "order=i" => \$order,
  "min-counts=s" => \$min_counts_string,
  "smoothing|s=s" => \$smoothing,
  "pre-processing|pre-proc=s" => \$preprocessing_flags,
  "working-dir|work-dir=s" => \$working_dir,
  "no-interpolation" => \$no_interpolation,
  "keep-files" => \$keep_files,
  "help|h" => \$_HELP
    );

if(!defined($text_file) || !defined($lm_file)) {
    $_HELP=1;
}

if(!defined($srilm_path)) {
    print STDERR "  --srilm-path=str must be set\n";
    $_HELP=1;
}


if($_HELP) {
    print "\nOptions:
  --text=str : plain text input file (one sentence per line)
  --lm=str : name of resulting LM file
  --srilm-path=str : path to srilm top directory
         generated by /install/scripts/oister-link-external-components.pl
  --batch-size=int : number of sentences per batch (default=1000000)
  --pre-processing=str : comma-separated values={lc,numsub,dedupl,sent_tags}
                 default=lc,numsub,dedupl,sent_tags
  --working-dir=str : new directory to store temporary file
                  (default=working_dir)
  --order=int : n-gram order of LM (default=5)
  --min-counts=str : min frequence of events for respective order
                (default=1-1-1-2-2)
  --smoothing=str : smoothing scheme (default=kndiscount)
  --no-interpolation : do not interpolate with lower-order models
  --keep-files : keep temporary files for debugging purposes
  --help : print this message.\n\n";
    exit(-1);
}

print STDERR "Unprocessed by Getopt::Long\n" if $ARGV[0];
foreach (@ARGV) {
  print STDERR "$_\n";
}


my $srilm_bin="$srilm_path/bin/";
my $srilm_machine_type_bin=&get_srilm_bin_machine_type_dir($srilm_path);
my $srilm_machine_type_bin_path="$srilm_path/bin/$srilm_machine_type_bin";

print $srilm_machine_type_bin;

my $PATH=$ENV{'PATH'};
$ENV{'PATH'}="$PATH:$srilm_bin:$srilm_machine_type_bin_path";
print STDERR "ENV{'PATH'}=$ENV{'PATH'}\n";


my $gtmins=&make_gtmin_string($order,$min_counts_string);
my $smoother=&set_smoothing($smoothing);
my $interpolation="-interpolate";
if($no_interpolation) {
    $interpolation="";
}

my $srilm_parameters="-order $order $interpolation $smoother $gtmins";
$srilm_parameters=~s/ +/ /g;
$srilm_parameters=~s/^ +//;
$srilm_parameters=~s/ +$//;
print STDERR "parameters=$srilm_parameters\n";
print STDERR "batch_size=$batch_size\n";


if($text_file=~/^biglm/) {
    print STDERR "file names can't begin with \"biglm\". Please use a different name.\n";
    exit(-1);
}

if(!-e "$text_file") {
    print STDERR "No such text file: $text_file\n";
    exit(-1);
}

if($text_file eq $lm_file) {
    print STDERR "Error: values for --text and --lm must be different.\n";
    exit(-1);
}

if(-e "$working_dir") {
    print STDERR "working dir: $working_dir exists.\nPlease use a different name for your working directory file or remove the existing directory.\n";
    exit(-1);
}

if(-e "$lm_file") {
    print STDERR "lm file \"$lm_file\" already exists. Please change the name of the text file.\n";
    exit(-1);
}

my $preprocessing_pipeline='';
if($preprocessing_flags ne '') {
    my %flags;
    my(@parts)=split(/\,/,$preprocessing_flags);
    for(my $i=0; $i<@parts; $i++) {
	$flags{$parts[$i]}=1;
    }
    undef @parts;
    if(exists($flags{'lc'})) {
	push(@parts,"$Bin/./lowercase.pl");
    }
    if(exists($flags{'numsub'})) {
	push(@parts,"$Bin/./substitute_numbers.pl");
    }
    if(exists($flags{'dedupl'})) {
	push(@parts,"sort -u -T $working_dir");
    }
    if(exists($flags{'sent_tags'})) {
	push(@parts,"$Bin/./add_sent_tags.pl");
    }
    $preprocessing_pipeline=join(" \| ",@parts);
}


$working_dir=File::Spec->rel2abs($working_dir);

print STDERR "mkdir $working_dir\n";
system("mkdir $working_dir");
print STDERR "mkdir $working_dir/lm\n";
system("mkdir $working_dir/lm");
print STDERR "mkdir $working_dir/lm/split\n";
system("mkdir $working_dir/lm/split");


if($preprocessing_pipeline ne '') {
    my($text_file_name)=$text_file=~/^.*?([^\/]+)$/;
    my $preprocessing_call="cat $text_file \| $preprocessing_pipeline > $working_dir/$text_file_name.pre";
    print STDERR "$preprocessing_call\n";
    system($preprocessing_call);
    $text_file="$working_dir/$text_file_name.pre";
    $text_file=File::Spec->rel2abs($text_file);
}

print STDERR "split -l$batch_size $text_file $working_dir/lm/split/en\n";
system("split -l$batch_size $text_file $working_dir/lm/split/en");

print STDERR "find $working_dir/lm/split -not -name 'file-list.en' -type f > $working_dir/lm/split/file-list.en\n";
system("find $working_dir/lm/split -not -name 'file-list.en' -type f > $working_dir/lm/split/file-list.en");

print STDERR "make-batch-counts $working_dir/lm/split/file-list.en 10 cat $working_dir/lm/counts $srilm_parameters\n";
system("make-batch-counts $working_dir/lm/split/file-list.en 10 cat $working_dir/lm/counts $srilm_parameters");

print STDERR "merge-batch-counts $working_dir/lm/counts >& merge_final.$$\n";
system("merge-batch-counts $working_dir/lm/counts >& merge_final.$$");

my $final_count_file;
open(F,"<merge_final.$$");
while(defined(my $line=<F>)) {
    if($line=~/^final counts in (.*)\n/) {
	$final_count_file=$1;
    }
}
close(F);
print STDERR "final count file: $final_count_file\n";
unlink("merge_final.$$");

print STDERR "make-big-lm $srilm_parameters -read $final_count_file -lm $lm_file\n";
system("make-big-lm $srilm_parameters -read $final_count_file -lm $lm_file");

#clean up:
if(!$keep_files) {
    print STDERR "rm -rf biglm*\n";
    system("rm -rf biglm*");
    print STDERR "rm -rf $working_dir*\n";
    system("rm -rf $working_dir*");
}

sub make_gtmin_string {
    my($order,$min_counts_string)=@_;
    my @base_gtmins=split(/\-/,$min_counts_string);
    unshift(@base_gtmins,'1');

    for(my $i=1; $i<=$order; $i++) {
	if(!defined($base_gtmins[$i])) {
	    if($i<3) {
		$base_gtmins[$i]=1;
	    } else {
		$base_gtmins[$i]=3;
	    }
	}
	$base_gtmins[$i]="\-gt$i" . "min $base_gtmins[$i]";
    }
    shift(@base_gtmins);
    return join(' ',@base_gtmins);
}


sub set_smoothing {
    my($smoothing)=@_;

    if($smoothing=~/^(kn|kneser-ney|kndiscount)$/) {
	return '-kndiscount';
    } elsif($smoothing=~/^(wb|witten-bell|wbdiscount)$/) {
	return '-wbdiscount';
    } else {
	return '-kndiscount';
    }
}


sub get_srilm_bin_machine_type_dir {
    my($srilm_path)=@_;
    my $common_dir="$srilm_path/common";
    print STDERR "common_dir=$common_dir\n";
    my %srilm_machine_types;
    opendir(D,"$common_dir");
    while(defined(my $makefile=readdir(D))) {
        if($makefile=~/^Makefile\.machine\.(.+)$/) {
            my $machine_type=$1;
            $srilm_machine_types{$machine_type}=1;
        }
    }
    closedir(D);

    my $machine_type_bin_dir;
    foreach my $machine_type (keys %srilm_machine_types) {
        if(-e "$srilm_path/bin/$machine_type" && -d "$srilm_path/bin/$machine_type") {
           $machine_type_bin_dir="$srilm_path/bin/$machine_type";
           $machine_type_bin_dir=$machine_type;
           last;
           }
         if(-e "$srilm_path/bin/$machine_type\_c" && -d "$srilm_path/bin/$machine_type\_c") {
             #           $machine_type_bin_dir="$srilm_path/bin/$machine_type\_c";
             $machine_type_bin_dir="$machine_type\_c";
             last;
             }
     }

     return $machine_type_bin_dir;
    }

